{"version":3,"sources":["Algorithms/AlgoUtils/gridUtils.js","components_utils/gridToggle.js","context/GridContext.js","components/Cell.jsx","components/GridLayout.jsx","Algorithms/dijkstra.js","Algorithms/AlgoUtils/queue.js","Algorithms/bfs.js","components_utils/visualizeAlgo.js","components/controlPanel.jsx","App.js","index.js"],"names":["getUnvisitedNeighbors","currentNode","grid","diagonal","neighbors","s0","d0","s1","d1","s2","d2","s3","d3","row","col","isWall","push","length","filter","neighbour","isVisited","getNodesInShortestPathOrder","finishCell","shortestPath","previousNode","currentCell","isStart","reverse","createNode","START_CELL_ROW","START_CELL_COL","FINISH_CELL_ROW","FINISH_CELL_COL","isFinish","distance","Infinity","getNewGridWithWallToggled","newGrid","slice","node","newNode","getNewGridWithStartToggled","changeStart","changeFinish","GridContext","React","createContext","GridProvider","props","useRef","useState","setGrid","mouseIsPressed","setDiagonal","visitedCellsInOrder","cellsInShortestPathOrder","handleMouseDown","useCallback","current","prevGrid","handleMouseEnter","handleMouseLeave","handleMouseUp","useEffect","initGrid","currentRow","getInitialGrid","console","log","Provider","value","toogleDiagonal","status","resetPath","i","setTimeout","cell","document","getElementById","classList","remove","pathResetGrid","getNewGridWithPathReset","resetWalls","wallResetGrid","getNewGridWithWallsReset","children","Cell","onMouseDown","onMouseEnter","onMouseLeave","onMouseUp","dynamicStyleClass","id","className","memo","GridLayout","useContext","map","rowIdx","nodeIdx","sortNodesByDistance","unvisitedNodes","sort","nodeA","nodeB","updateUnvisitedNeighbors","unvisitedNeighbors","GRID","neighbor","getAllNodes","nodes","dijkstra","startNode","finishNode","visitedNodesInOrder","closestNode","shift","Queue","this","data","item","isEmpty","str","bfs","q","enqueue","dequeue","neighbours","require","animateAlgo","animateShortestPath","ControlPanel","draggable","type","onClick","diagonalCheckbox","checked","result","startCell","visualizeBFS","visualizeDijkstra","App","ReactDOM","render"],"mappings":"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","file":"static/js/main.c6da4e89.chunk.js","sourcesContent":["//helper fucntion to get unvisited , neigbouring nodes/cells (without walls)\r\nconst getUnvisitedNeighbors = (currentNode , grid , diagonal )=>{\r\n    const neighbors = [];\r\n    let s0 = false , d0 = false ,\r\n        s1 = false , d1 = false,\r\n        s2 = false , d2 = false,\r\n        s3 = false , d3 = false ;\r\n\r\n\r\n    const {row , col } = currentNode;                           \r\n    \r\n    if (row > 0) \r\n    {\r\n        if(!grid[row - 1][col].isWall ){\r\n        neighbors.push(grid[row - 1][col]);  //up\r\n        s0 = true ;}\r\n\r\n    } \r\n    if (col < grid[0].length - 1) \r\n    {\r\n        if(!grid[row][col + 1].isWall ){\r\n        neighbors.push(grid[row][col + 1]);\r\n        s1 = true ;}           //front\r\n    }\r\n    if (row < grid.length - 1) \r\n    {\r\n        if(!grid[row + 1][col].isWall ){\r\n        neighbors.push(grid[row + 1][col]);\r\n        s2 = true ;}              //down\r\n    }\r\n    if (col > 0) \r\n    {\r\n        if(!grid[row][col - 1].isWall ){\r\n        neighbors.push(grid[row][col - 1]);\r\n        s3 = true ;}                            //back\r\n    }\r\n\r\n    if(diagonal === true)\r\n    {\r\n        d0 = s3 || s0;\r\n        d1 = s0 || s1;\r\n        d2 = s1 || s2;\r\n        d3 = s2 || s3;\r\n\r\n        if(row>0 && col>0 && row<grid.length-1 && col<grid[0].length-1)\r\n        {\r\n            if(d0 && !grid[row - 1][col - 1].isWall )  \r\n            neighbors.push(grid[row - 1][col - 1]);\r\n            \r\n            if(d1 && !grid[row - 1][col + 1].isWall ) \r\n            neighbors.push(grid[row - 1][col + 1]);\r\n\r\n            if(d2 && !grid[row + 1][col + 1].isWall )\r\n            neighbors.push(grid[row + 1][col + 1]);\r\n\r\n            if(d3 && !grid[row + 1][col - 1].isWall ) \r\n            neighbors.push(grid[row + 1][col - 1]);\r\n        }\r\n    }\r\n    \r\n    return neighbors.filter(neighbour => !neighbour.isVisited);;\r\n};\r\n\r\n//to get the shortest path \r\nconst getNodesInShortestPathOrder = (finishCell)=>{\r\n\r\n    let shortestPath = [];\r\n\r\n    if(finishCell.previousNode === null)\r\n    return shortestPath;\r\n    \r\n    let currentCell = finishCell;\r\n\r\n    while(!currentCell.isStart)\r\n    {\r\n        shortestPath.push(currentCell);\r\n        currentCell = currentCell.previousNode;\r\n    }\r\n    shortestPath.push(currentCell);\r\n    \r\n    return shortestPath.reverse();\r\n}\r\n\r\nexport {\r\n    getUnvisitedNeighbors,\r\n    getNodesInShortestPathOrder\r\n}","\r\n//-----------------inititalize the GRID state--------------------\r\nconst getInitialGrid = (START_CELL_ROW,START_CELL_COL,FINISH_CELL_ROW,FINISH_CELL_COL) => {\r\n    const grid = [];\r\n    for (let row = 0; row < 25; row++) {\r\n      const currentRow = [];\r\n      for (let col = 0; col < 52; col++) {\r\n        currentRow.push(createNode(col, row , START_CELL_ROW,START_CELL_COL,FINISH_CELL_ROW,FINISH_CELL_COL));\r\n      }\r\n      grid.push(currentRow);\r\n    }\r\n    return grid;\r\n  };\r\n\r\n  //------------------------create individual node/cell with default property---------------------------\r\nconst createNode = (col, row ,START_CELL_ROW,START_CELL_COL,FINISH_CELL_ROW,FINISH_CELL_COL) => {\r\nreturn {\r\n    row,\r\n    col,\r\n    isStart: row === START_CELL_ROW && col === START_CELL_COL,\r\n    isFinish: row === FINISH_CELL_ROW && col === FINISH_CELL_COL,\r\n    distance: Infinity,\r\n    isVisited: false,\r\n    isWall: false,\r\n    previousNode: null,\r\n};\r\n};\r\n\r\n//--------------to change a wall property of a cell----------------------------\r\nconst getNewGridWithWallToggled = (grid, row, col) => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  const newNode = {\r\n    ...node,\r\n    isWall: !node.isWall,\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n};\r\n\r\n//-----------------------to change start and end point------------------------\r\nconst getNewGridWithStartToggled = (grid, row ,col , changeStart ,changeFinish) =>{\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  const newNode = {\r\n    ...node,\r\n    isFinish : changeFinish ? node.isStart ? node.isFinish : !node.isFinish : node.isFinish,\r\n    isStart : changeStart ? node.isFinish ? node.isStart : !node.isStart : node.isStart,\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n};\r\n\r\n//---------------------------to reset path-----------------------------------------\r\nconst getNewGridWithPathReset = (grid,visitedCellsInOrder)=>{\r\n  const newGrid = grid.slice();\r\n  for ( const row of newGrid)\r\n  {\r\n    for( const cell of row)\r\n    {\r\n    const node = newGrid[cell.row][cell.col];\r\n    const newNode = {\r\n      ...node,\r\n      distance: Infinity,\r\n      isVisited : false,\r\n      previousNode: null,\r\n    };\r\n    newGrid[cell.row][cell.col] = newNode;\r\n    }\r\n  }\r\n  \r\n  return newGrid;\r\n};\r\n\r\n//-------------------reset wall/obstecles-----------------------\r\nconst getNewGridWithWallsReset = (grid)=>{\r\n  const newGrid = grid.slice();\r\n  for ( const row of newGrid)\r\n  {\r\n    for( const cell of row)\r\n    {\r\n    const node = newGrid[cell.row][cell.col];\r\n    const newNode = {\r\n      ...node,\r\n      isWall : node.isWall ? false : node.isWall,\r\n    };\r\n    newGrid[cell.row][cell.col] = newNode;\r\n    }\r\n  }\r\n  return newGrid;\r\n};\r\n\r\n\r\nexport {\r\n    getInitialGrid,\r\n    getNewGridWithPathReset,\r\n    getNewGridWithStartToggled,\r\n    getNewGridWithWallsReset,\r\n    getNewGridWithWallToggled\r\n};","import React , { useState , useEffect , useCallback , useRef } from 'react';\r\nimport {\r\n    getInitialGrid,\r\n    getNewGridWithPathReset,\r\n    getNewGridWithStartToggled,\r\n    getNewGridWithWallsReset,\r\n    getNewGridWithWallToggled\r\n  } from '../components_utils/gridToggle';\r\n\r\nexport const GridContext = React.createContext(null);\r\n\r\nconst GridProvider = (props) => {\r\n\r\n    //-------------state and variables declaration--------------------\r\n    const START_CELL_ROW = useRef(10);\r\n    const START_CELL_COL = useRef(16);\r\n    const FINISH_CELL_ROW = useRef(10);\r\n    const FINISH_CELL_COL = useRef(35);\r\n\r\n    const [grid , setGrid] = useState([]);\r\n    \r\n    let mouseIsPressed = false;\r\n    let changeStart = false;\r\n    let changeFinish = false;\r\n\r\n    let [diagonal , setDiagonal] = useState(false);\r\n    let visitedCellsInOrder = useRef([]);\r\n    let cellsInShortestPathOrder = useRef([]);\r\n\r\n    const toogleDiagonal = (status)=>{\r\n       setDiagonal(status);\r\n    };\r\n\r\n\r\n    //---------------reset path and walls-----------------------------------\r\n    const resetPath = ()=>{\r\n        \r\n        for (let i = 0; i < visitedCellsInOrder.current.length; i++) {\r\n          setTimeout(() => {\r\n            const cell = visitedCellsInOrder.current[i];\r\n            document.getElementById(`cell-${cell.row}-${cell.col}`).classList.remove(`cell-visited`);\r\n            document.getElementById(`cell-${cell.row}-${cell.col}`).classList.remove(`cell-shortest-path`);\r\n          }, 2 * i);\r\n        }\r\n        let pathResetGrid = getNewGridWithPathReset(grid,visitedCellsInOrder.current);\r\n        \r\n        setGrid(pathResetGrid);\r\n      };\r\n      \r\n    const resetWalls = ()=>{\r\n      const wallResetGrid = getNewGridWithWallsReset(grid);\r\n      setGrid(wallResetGrid);\r\n    };\r\n      \r\n      \r\n      \r\n    //--------------mouse control utilities-------------------\r\n    const handleMouseDown = useCallback((row, col) => {\r\n\r\n        if(row === START_CELL_ROW.current && col === START_CELL_COL.current)\r\n        {\r\n          changeStart = true;\r\n        }\r\n        else if(row === FINISH_CELL_ROW.current && col === FINISH_CELL_COL.current)\r\n        {\r\n          changeFinish = true;\r\n        }\r\n        else\r\n        {\r\n          setGrid(prevGrid=>{\r\n            const newGrid = getNewGridWithWallToggled(prevGrid, row, col);\r\n            return newGrid;\r\n          });\r\n        }\r\n        mouseIsPressed = true ;\r\n      },[]);\r\n    \r\n    \r\n    const handleMouseEnter = useCallback((row, col) => {\r\n      if (!mouseIsPressed) return;\r\n\r\n      if(changeStart || changeFinish)\r\n      {\r\n        if(changeStart)\r\n        { \r\n          START_CELL_ROW.current = row;\r\n          START_CELL_COL.current = col;\r\n        }\r\n        else \r\n        {\r\n          FINISH_CELL_ROW.current = row;\r\n          FINISH_CELL_COL.current = col;\r\n        }\r\n        setGrid(prevGrid=>{\r\n          const newGrid = getNewGridWithStartToggled(prevGrid, row ,col , changeStart , changeFinish);\r\n          return newGrid;\r\n        })\r\n      }\r\n      else\r\n      {\r\n        setGrid(prevGrid=>{\r\n          const newGrid = getNewGridWithWallToggled(prevGrid, row, col);\r\n          return newGrid;\r\n        });\r\n      }\r\n    },[]);\r\n\r\n    const handleMouseLeave = useCallback((row,col)=>{\r\n      if(changeStart || changeFinish)\r\n      {\r\n        setGrid(prevGrid=>{\r\n          const newGrid = getNewGridWithStartToggled(prevGrid, row ,col , changeStart , changeFinish);\r\n          return newGrid;\r\n        })\r\n      }\r\n    },[]);\r\n\r\n    const handleMouseUp = useCallback(() => {\r\n    mouseIsPressed = false;\r\n    changeStart = false;\r\n    changeFinish =  false;\r\n    },[]);\r\n          \r\n          \r\n\r\n    //---------------------initialize the grid--------------------------\r\n    useEffect(()=>{\r\n      const initGrid = getInitialGrid(START_CELL_ROW.current,START_CELL_COL.current,FINISH_CELL_ROW.current,FINISH_CELL_COL.current);\r\n      setGrid(initGrid);\r\n    },[]);\r\n\r\n    useEffect(()=>{\r\n      console.log(\"changed\");\r\n    },[diagonal.current]);\r\n\r\n    //----------------------JSX-------------------------------\r\n    return(\r\n      <GridContext.Provider value={ { grid , \r\n        diagonal ,\r\n        toogleDiagonal ,\r\n        START_CELL_ROW , \r\n        START_CELL_COL , \r\n        FINISH_CELL_ROW , \r\n        FINISH_CELL_COL , \r\n        visitedCellsInOrder , \r\n        cellsInShortestPathOrder , \r\n        resetPath , \r\n        resetWalls , \r\n        handleMouseDown , \r\n        handleMouseEnter , \r\n        handleMouseLeave , \r\n        handleMouseUp } }>\r\n          { props.children }\r\n      </GridContext.Provider>\r\n  );\r\n};\r\n\r\nexport default GridProvider;\r\n","import React from 'react';\r\n\r\nimport './Cell.css';\r\n\r\nlet Cell = ({ col, row , isFinish, isStart, isWall, onMouseDown, onMouseEnter, onMouseLeave , onMouseUp })=>{\r\n    console.log(`Cell is rendered`);\r\n\r\n    const dynamicStyleClass = isFinish ? 'cell-finish' :\r\n    isStart ? 'cell-start' : \r\n    isWall ? 'cell-wall' : '';\r\n\r\n    return (\r\n        <div\r\n          id={`cell-${row}-${col}`}\r\n          className={`cell ${dynamicStyleClass}`}\r\n          onMouseDown={() => onMouseDown(row, col)}\r\n          onMouseEnter={() => onMouseEnter(row, col)}\r\n          onMouseLeave={ () => onMouseLeave(row , col)}\r\n          onMouseUp={() => onMouseUp()}\r\n          >\r\n          </div>);};\r\n\r\nCell = React.memo(Cell);\r\n\r\n\r\nexport default Cell;","import React , { useContext } from 'react';\r\nimport { GridContext } from '../context/GridContext';\r\nimport './GridLayout.css';\r\n\r\n//---------child component-------------------\r\nimport Cell from './Cell';\r\n\r\n\r\n\r\n//---------------React Functional Component--------------------\r\nconst GridLayout = ()=>{\r\n\r\n    const { grid , handleMouseDown , handleMouseEnter\r\n      , handleMouseLeave , handleMouseUp } = useContext(GridContext);\r\n     \r\n    \r\n    //--------------JSX--------------------------\r\n    return(\r\n        <div className=\"center-layout\">\r\n            \r\n            <div className=\"grid\">\r\n            {grid.map((row, rowIdx) => {\r\n                return (\r\n                <div key={rowIdx} className=\"row\">\r\n                    {row.map((node, nodeIdx) => {\r\n                    const {row, col, isFinish, isStart, isWall} = node;\r\n                        return (\r\n                            <Cell\r\n                            key={nodeIdx}\r\n                            col={col}\r\n                            row={row}\r\n                            isFinish={isFinish}\r\n                            isStart={isStart}\r\n                            isWall={isWall}\r\n                            onMouseDown={ handleMouseDown }\r\n                            onMouseEnter={ handleMouseEnter }\r\n                            onMouseLeave={ handleMouseLeave }\r\n                            onMouseUp={ handleMouseUp }\r\n                            />\r\n                        );\r\n                    })}\r\n                </div>\r\n                );\r\n            })}\r\n            </div>\r\n        </div>\r\n    )\r\n};\r\n\r\n\r\nexport default GridLayout;","import * as GRID from './AlgoUtils/gridUtils';\r\n\r\n// Performs Dijkstra's algorithm\r\nconst dijkstra = (grid, startNode, finishNode , diagonal) => {\r\n  \r\n  const visitedNodesInOrder = [];\r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid);\r\n\r\n  while (unvisitedNodes.length) {\r\n    sortNodesByDistance(unvisitedNodes);\r\n    const closestNode = unvisitedNodes.shift();\r\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    updateUnvisitedNeighbors(closestNode, grid, diagonal);\r\n  }\r\n}\r\n\r\nconst sortNodesByDistance = (unvisitedNodes) => {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nconst updateUnvisitedNeighbors = (node, grid, diagonal) => {\r\n  const unvisitedNeighbors = GRID.getUnvisitedNeighbors(node, grid , diagonal);\r\n  \r\n  for (const neighbor of unvisitedNeighbors) {\r\n    if(neighbor.distance === Infinity)\r\n    { \r\n      neighbor.distance = node.distance + 1;\r\n      neighbor.previousNode = node;\r\n    }\r\n  }\r\n}\r\n\r\nconst getAllNodes = (grid) => {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\nexport default dijkstra;\r\n","class Queue {\r\n    constructor() {\r\n      this.data = [];\r\n    }\r\n   \r\n    // Adds an element to the queue\r\n    enqueue(item) {\r\n      this.data.push(item);\r\n    }\r\n    \r\n    \r\n    // removing element from the queue \r\n    dequeue() {\r\n      if (this.isEmpty()) {\r\n        return \"Underflow\";\r\n      }\r\n      return this.data.shift();\r\n    }\r\n  \r\n    // returns the Front element of\r\n    front() { \r\n      if (this.isEmpty())\r\n        return \"No elements in Queue\";\r\n      return this.data[0];\r\n    }\r\n  \r\n    // isEmpty function \r\n    // return true if the queue is empty.\r\n    isEmpty() {\r\n       \r\n      return this.data.length === 0;\r\n    }\r\n\r\n    printQueue() \r\n    {\r\n        let str = \"\";\r\n        for(let i = 0; i < this.data.length; i++)\r\n            str = `${str} ${this.data[i].row} , ${this.data[i].col} `;\r\n        return str; \r\n    } \r\n  }\r\n  \r\nexport default Queue;","//import queue \r\nimport Queue from './AlgoUtils/queue';\r\nimport * as GRID from './AlgoUtils/gridUtils';\r\n\r\n//perform BREATH FIRST SEARCH \r\nconst bfs = (grid, startNode, finishNode , diagonal)=>{\r\n    const q = new Queue();\r\n\r\n    let visitedNodesInOrder = [];\r\n\r\n    startNode.isVisited = true;\r\n    q.enqueue(startNode); \r\n    visitedNodesInOrder.push(startNode);\r\n    \r\n\r\n    while(!q.isEmpty())\r\n    {\r\n        const currentNode = q.dequeue();\r\n\r\n        if(currentNode.isFinish === true)\r\n        {\r\n            break;\r\n        }\r\n\r\n        const neighbours = GRID.getUnvisitedNeighbors(currentNode,grid,diagonal);    //donot include walls\r\n        \r\n        for (const node of neighbours)\r\n        {\r\n                node.isVisited = true;\r\n                node.previousNode = currentNode;\r\n                q.enqueue(node);\r\n                visitedNodesInOrder.push(node);\r\n        }\r\n    }\r\n    \r\n    return visitedNodesInOrder;\r\n}\r\n\r\nexport default bfs;\r\n","import dijkstra from '../Algorithms/dijkstra';\r\nimport bfs from '../Algorithms/bfs';\r\nconst { getNodesInShortestPathOrder } = require('../Algorithms/AlgoUtils/gridUtils');\r\n\r\n    //animate the iterartion path of algorithm\r\n    const animateAlgo = (visitedCellsInOrder, cellsInShortestPathOrder) => {\r\n        for (let i = 0; i < visitedCellsInOrder.length; i++) {\r\n          if (i === visitedCellsInOrder.length-1) {\r\n            setTimeout(() => {\r\n              animateShortestPath(cellsInShortestPathOrder);\r\n            }, 7 * i);\r\n            return;\r\n          }\r\n          setTimeout(() => {\r\n            const cell = visitedCellsInOrder[i];\r\n            if(cell.isStart === false && cell.isFinish === false )\r\n            {\r\n              document.getElementById(`cell-${cell.row}-${cell.col}`).className =\r\n              'cell cell-visited';\r\n            }\r\n          }, 7 * i);\r\n        }\r\n      };\r\n\r\n    //animate the shortest path\r\n    const animateShortestPath = (cellsInShortestPathOrder) => {\r\n        for (let i = 0; i < cellsInShortestPathOrder.length; i++) {\r\n          setTimeout(() => {\r\n            const cell = cellsInShortestPathOrder[i];\r\n            if(cell.isStart === false && cell.isFinish === false )\r\n            {\r\n              document.getElementById(`cell-${cell.row}-${cell.col}`).className =\r\n              'cell cell-shortest-path';\r\n            }\r\n          }, 50 * i);\r\n        }\r\n      }\r\n\r\n    //to visualize the Dijkastra algorithm\r\n    const visualizeDijkstra = (grid,\r\n      diagonal,\r\n      START_CELL_ROW,\r\n      START_CELL_COL,\r\n      FINISH_CELL_ROW,\r\n      FINISH_CELL_COL) => {\r\n  \r\n        const startCell = grid[START_CELL_ROW][START_CELL_COL];\r\n        const finishCell = grid[FINISH_CELL_ROW][FINISH_CELL_COL];\r\n  \r\n        let visitedCellsInOrder = dijkstra(grid, startCell, finishCell , diagonal);        \r\n        let cellsInShortestPathOrder = getNodesInShortestPathOrder(finishCell);\r\n        animateAlgo(visitedCellsInOrder, cellsInShortestPathOrder);\r\n\r\n        return {\r\n            visitedCellsInOrder,\r\n            cellsInShortestPathOrder\r\n        };\r\n      };\r\n\r\n      //to animate the BFS algo\r\n      const visualizeBFS = (grid,\r\n        diagonal,\r\n        START_CELL_ROW,\r\n        START_CELL_COL,\r\n        FINISH_CELL_ROW,\r\n        FINISH_CELL_COL) => {\r\n        const startCell = grid[START_CELL_ROW][START_CELL_COL];\r\n        const finishCell = grid[FINISH_CELL_ROW][FINISH_CELL_COL];\r\n        \r\n        let visitedCellsInOrder = bfs(grid, startCell, finishCell , diagonal );\r\n        let cellsInShortestPathOrder = getNodesInShortestPathOrder(finishCell);\r\n        animateAlgo(visitedCellsInOrder, cellsInShortestPathOrder);\r\n\r\n        return {\r\n            visitedCellsInOrder,\r\n            cellsInShortestPathOrder\r\n        };\r\n      };\r\n\r\n\r\nexport {\r\n    visualizeBFS,\r\n    visualizeDijkstra\r\n};","import React , { useContext } from 'react';\r\nimport {GridContext } from '../context/GridContext';\r\nimport {visualizeBFS, visualizeDijkstra} from '../components_utils/visualizeAlgo';\r\nimport './Panel.css';\r\n\r\nconst ControlPanel = () =>{\r\n    \r\n    const { \r\n            toogleDiagonal ,\r\n            resetPath , \r\n            resetWalls ,\r\n            visitedCellsInOrder , \r\n            cellsInShortestPathOrder } = useContext(GridContext);\r\n    const { grid ,\r\n            diagonal ,\r\n            START_CELL_ROW , \r\n            START_CELL_COL , \r\n            FINISH_CELL_ROW , \r\n            FINISH_CELL_COL } = useContext(GridContext);\r\n\r\n     //--------------diagonal toogle------------\r\n     const handleDiagonal = () => { \r\n        const diagonalCheckbox = document.getElementById('diagoCheck');\r\n        toogleDiagonal(diagonalCheckbox.checked);\r\n     };\r\n\r\n     //-------------------algo -------------------\r\n     const handleDijkastraVisual = ()=>{\r\n        let result = visualizeDijkstra(grid,\r\n          diagonal,\r\n          START_CELL_ROW.current,\r\n          START_CELL_COL.current,\r\n          FINISH_CELL_ROW.current,\r\n          FINISH_CELL_COL.current);\r\n        \r\n        visitedCellsInOrder.current = result.visitedCellsInOrder;\r\n        cellsInShortestPathOrder.current = result.cellsInShortestPathOrder;\r\n      };\r\n  \r\n      const handleBfsVisual = () =>{\r\n        let result = visualizeBFS(grid,\r\n          diagonal,\r\n          START_CELL_ROW.current,\r\n          START_CELL_COL.current,\r\n          FINISH_CELL_ROW.current,\r\n          FINISH_CELL_COL.current);\r\n        \r\n        visitedCellsInOrder.current = result.visitedCellsInOrder;\r\n        cellsInShortestPathOrder.current = result.cellsInShortestPathOrder;\r\n      };\r\n\r\n\r\n    return(\r\n        <div id=\"play_panel\" className=\"panel center_panel\" draggable={ true } >\r\n            <label className=\"switch\">\r\n            <input type=\"checkbox\"\r\n            id=\"diagoCheck\"\r\n            onClick={ handleDiagonal }/>\r\n            <span className=\"slider\"></span>\r\n            </label>\r\n            <button \r\n            id=\"button1\" \r\n            className=\"button\"\r\n            onClick={ handleBfsVisual }>BFS Search</button>\r\n            <button \r\n            id=\"button2\" \r\n            className=\"button\"\r\n            onClick={ handleDijkastraVisual }>Dijikastra Search</button>\r\n            <button \r\n            id=\"button3\" \r\n            className=\"button\"\r\n            onClick={ resetPath } >Clear Path</button>\r\n            <button \r\n            id=\"button4\" \r\n            className=\"button\"\r\n            onClick={ resetWalls }>Clear Walls</button>\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default ControlPanel;","import React from 'react';\r\nimport GridLayout from './components/GridLayout';\r\nimport ControlPanel from './components/controlPanel';\r\nimport GridProvider from './context/GridContext';\r\n\r\nfunction App() {\r\n  return (\r\n    <GridProvider>\r\n    <div className=\"app\">\r\n      <GridLayout />\r\n      <ControlPanel/>\r\n    </div>\r\n    </GridProvider>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport App from './App';\r\nimport './index.css';\r\n\r\nReactDOM.render(\r\n    <App />,\r\n  document.getElementById('root')\r\n);\r\n\r\n\r\n"],"sourceRoot":""}